Идея метода состоит в том, чтобы создавать отсортированную последовательность путем присоединения к ней одного элемента за другим в правильном порядке.

Будем строить готовую последовательность, начиная с левого конца массива. Алгоритм состоит из n последовательных шагов, начиная от нулевого и заканчивая (n-1)-м.

На i-м шаге выбираем наименьший из элементов a[i] ... a[n] и меняем его местами с a[i]

Вне зависимости от номера текущего шага i, последовательность a[0]...a[i] является упорядоченной. Таким образом, на (n-1)-м шаге вся последовательность, кроме a[n] оказывается отсортированной, а a[n] стоит на последнем месте по праву: все меньшие элементы уже ушли влево.

Код:
template<class T>
void selectSort(T a[], long size) {
  long i, j, k; 
  T x;

  for( i=0; i < size; i++) {   	// i - номер текущего шага
    k=i; x=a[i];

    for( j=i+1; j < size; j++)	// цикл выбора наименьшего элемента
      if (  a[j] < x ) {
        k=j; x=a[j];	        // k - индекс наименьшего элемента
      }

    a[k] = a[i]; a[i] = x;   	// меняем местами наименьший с a[i]
  }
}
